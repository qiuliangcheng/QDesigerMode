## 工厂模式
* 我有一个产品抽象类 可以衍生出很多的派生类产品，然后我通过一个工厂类对不同的产品进行生产

```c++
    在这个例子中，为有一个电脑的产品抽象类，基于他拥有笔记本电脑和台式电脑。我通过使用一个工厂类，可以根据需要哪个产品就生产出哪个产品
```


## 抽象工厂模式
* 这个和工厂模式差不多，但是这个的区别在于可能为需要生产的类中和另一个类也有联系，在例子中体现在，我的工厂类中需要同时具有User和pattern类，所以需要不同的工厂类分别对不同的有关系的类进行生产，例如：
```c++
    我可以产生一个派生的工厂类，其中这个派生类专门生产类A B，另一个生产A C，另一个生产BC，可以根据需要的类的关联进行设计生产

```

## 适配器类
* 如果类A和类B是同一个类的派生类并且拥有相同的接口，而类C与他们不一样，但是我也希望能够调用A和B相同的接口区调用C，这个时候就可以使用适配器模式

```c++
    比如现在姚明去打球，有两个外国球员和他们一队，但是外国球员用的是英语，这个时候就需要一个中介 去封装姚明，这样姚明能通过中介使用一样的接口和外国球员

```
## 单例模式
* 全局只使用一个类 有分懒汉和俄汉，俄汉模式下对象一开始就初始化了，懒汉只有第一次用的时候会初始化，通过static关键字可以直接保证线程安全


## 观察者模式
* 一个主题的变化 能够通知所有正在观察这个主题的人，publish->subcribe模式
```c++
    在本例子中，Clock是一个主题，他被很多观察者所监控，他发生了变化就会通知所有的观察者，在同志方法里对观察者进行通知处理操作。

```

## 桥接模式
* 本质是将两个类的关系进行分离，使得他们独立的变化 因为继承是一种强耦合的关系 用桥街可以解耦
```c++
    在本例子中，每个手机都有一个软件 我这个软件可以自行的添加定义，然后我有一个手机品牌的即类，我可以有不同的手机品牌 这个也是我可以自己定义的  为通过在基类加入一个设置手机软件的 setHandsetsoft方法，可以使得手机品牌和软件进行解耦，需要的时候加入。

```

## 策略模式
* 策略模式定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化不会影响到使用算法的客户。通过context对不同的策略进行封装选择，减小算法的改变对客户端的影响，客户端只需要进行选择算法就可以，而不需要一个算法一个客户端这样实现。

## 原型模式
* 这个模式可以直接拷贝一个基类，但是普通的拷贝构造进行的是基类自身的拷贝，而无法拷贝一个基类（指向一个派生类的对象）。原型模式解决了这个问题
